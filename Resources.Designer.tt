<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.ComponentModel.Design" #>
<#@ output extension=".cs" #><#

var resxItem = GetResxProjectItem();
var resxPath = resxItem.FileNames[0];
var localNamespace = GetLocalNamespace(resxItem);
var className = Path.GetFileNameWithoutExtension(resxPath).Replace(".", "_");

using var reader = new ResXResourceReader(resxPath) {UseResXDataNodes = true, BasePath=Path.GetDirectoryName(resxPath)};
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// 
// This template generates PublicResXFileCodeGenerator compatible code plus some
// useful extensions. 
// 
// The original version provided by ResXResourceManager is restricted to resource key names
// that are valid c# identifiers to keep this template simple (KISS!).
// 
// Us it as it is or as a scaffold to generate the code you need.
//
// As long as you have ResXResourceManager running in the background, the generated code 
// will be kept up to date.
//  
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;

namespace <#= localNamespace #>;

/// <summary>
/// ローカライズされた文字列などを検索するための、厳密に型指定されたリソース クラスです。
/// </summary>
// This class was auto-generated by a text template.
// To add or remove a member, edit your .ResX file.
[global::System.CodeDom.Compiler.GeneratedCodeAttribute("ResXResourceManager", "1.0.0.0")]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
internal class <#= className #>
{
    private static global::System.Resources.ResourceManager resourceMan;        
    private static global::System.Globalization.CultureInfo resourceCulture;
        
    [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    internal <#= className #>() {
    }
        
    /// <summary>
    /// このクラスで使用されているキャッシュされた ResourceManager インスタンスを返します。
    /// </summary>
    [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
    public static global::System.Resources.ResourceManager ResourceManager
        => resourceMan ??= new CustomResourceManager("<#= localNamespace #>.<#= className #>", Assembly.GetExecutingAssembly());
        
    /// <summary>
    /// すべてについて、現在のスレッドの CurrentUICulture プロパティをオーバーライドします
    /// 現在のスレッドの CurrentUICulture プロパティをオーバーライドします。
    /// </summary>
    [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
    public static global::System.Globalization.CultureInfo Culture
    {
        get => resourceCulture;
        set => resourceCulture = value;
    }
<#
    foreach (var node in GetResxNodes(reader))
    {
        if (node.Type == typeof (string))
        {
#>

    /// <summary>
    /// "<#= XmlEscape(node.Value, 50) #>" に類似しているローカライズされた文字列を検索します。
    /// </summary>
<# InsertRemarks(node.Comment); #>
    public static string <#= node.Key #> => ResourceManager.GetString("<#= node.Key #>", resourceCulture) ?? string.Empty;
<#
        }
        else
        {
#>

    /// <summary>
    /// Looks up a localized resource of type <#= node.Type.FullName #>.
    /// </summary>
<# InsertRemarks(node.Comment); #>
    public static <#= node.Type.FullName #> <#= node.Key #> => ((<#= node.Type.FullName #>)(ResourceManager.GetObject("<#= node.Key #>", resourceCulture)));
<#
        }
    }
#>
}
<#+
ProjectItem GetResxProjectItem()
{
    var serviceProvider = (IServiceProvider)Host;
    var dte = (DTE2)serviceProvider.GetCOMService(typeof(DTE));
    var ttItem = dte.Solution.FindProjectItem(Host.TemplateFile);
    return (ProjectItem)ttItem.Collection.Parent;        
}

string GetLocalNamespace(ProjectItem resxItem)
{
    var resxPath = resxItem.FileNames[0];
    var resxFolder = Path.GetDirectoryName(resxPath);
    var project = resxItem.ContainingProject;
    var projectFolder = Path.GetDirectoryName(project.FullName);
    var rootNamespace = project.Properties.Item("RootNamespace").Value.ToString();

    var localNamespace = rootNamespace;
    if (resxFolder.StartsWith(projectFolder, StringComparison.OrdinalIgnoreCase))
    {
        localNamespace += resxFolder.Substring(projectFolder.Length).Replace('\\', '.');
    }

    return localNamespace;
}

void InsertRemarks(string comment)
{
    if (string.IsNullOrEmpty(comment)) 
        return;

    WriteLine("    /// <remarks>");
    WriteLine("    /// " + XmlEscape(comment));
    WriteLine("    /// </remarks>");
}

struct ResxNode
{
    public string Key;
    public string Value;
    public string Comment;
    public Type Type;
}

IEnumerable<ResxNode> GetResxNodes(ResXResourceReader reader)
    => reader.Cast<DictionaryEntry>()
        .Select(item => (ResXDataNode)item.Value)
        .Select(node => new ResxNode
        {
            Key = node.Name,
            Comment = node.Comment,
            Value = node.GetValue((ITypeResolutionService)null) as string,
            Type = Type.GetType(node.GetValueTypeName((ITypeResolutionService)null))
        })
        .OrderBy(node => node.Key);

string XmlEscape(string value)
    => value
        .Replace("\n", "&#10;")
        .Replace("\r", "&#13;")
        .Replace(">", "&gt;")
        .Replace("<", "&lt;")
        .Replace("&", "&amp;");

string XmlEscape(string value, int maxLen)
{
    value = XmlEscape(value);
    if (value.Length <= maxLen)
        return value;
        
    return value.Substring(0, maxLen) + "...";
}
#>